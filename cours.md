---
marp: true
theme: default
paginate: true
math: mathjax
---
<style>
section::after {
    content: attr(data-marpit-pagination) '/' attr(data-marpit-pagination-total) 
}
</style>

# Cours d'introduction √† Terraform

Formation Infrastructure as Code avec Terraform

---

## Table des mati√®res

1. Introduction √† l'Infrastructure en tant que Code
2. Qu'est-ce que Terraform ?
3. Approches traditionnelles vs Terraform
4. Terraform vs Ansible
5. Concepts fondamentaux

---

## Table des mati√®res (suite)

6. Flux de travail Terraform
7. Concepts avanc√©s
8. Outils alternatifs

## D√©roulement de la journ√©e

  Cours puis TP, ce matin et cet apr√®s-midi

---

# 1. Introduction √† l'Infrastructure en tant que Code

---

## Qu'est-ce que l'IaC ?

L'Infrastructure en tant que Code est la pratique de gestion et d'approvisionnement de l'infrastructure via des fichiers de d√©finition lisibles par machine.

---

## Avantages cl√©s de l'IaC

- **"gitable"**
  - Contr√¥le de version pour suivre les modifications
  - Collaboration
- **Reproductible**
  - Environnements identiques
  - **Automatisation** : R√©duction des erreurs humaines
- **Documentation** : Le code est source de documentation

---

## √âvolution : Configuration manuelle

**Ann√©es 1990-2000**
- Pas de cloud
- Pas de virtualisation
- Pas de conteneurs
- Les infrastructures sont g√©n√©ralement de taille modeste
- Configuration manuelle via SSH/RDP
- Documentation dans des wikis
- Sujet √† la d√©rive et l'incoh√©rence

---

## √âvolution : Gestion de configuration

**Ann√©es 2000-2010**
- Pas de cloud
- D√©but de la virtualisation
- Pas de conteneurs
- La taille des infrastructures augmente
- Outils : Puppet, Chef, Ansible
- Automatisation de la configuration
- Focus sur la configuration logicielle

---

## √âvolution : Infrastructure as Code

**Ann√©es 2010-aujourd'hui**
- D√©but du cloud
- D√©but des conteneurs
- Explosion de la taille des infrastructures et de la diversit√© de leurs composants
- Outils : Terraform, CloudFormation
- Cycle de vie complet de l'infrastructure

---

# 2. Qu'est-ce que Terraform ?

---

## Vue d'ensemble

**Terraform** est un outil d'_Infrastructure as Code_ open-source cr√©√© par HashiCorp.

Il permet de d√©finir des ressources cloud et on-premise dans des fichiers de configuration lisibles.

---

## Caract√©ristiques cl√©s

- **Langage d√©claratif** : D√©crire ce que vous voulez
- **Agnostique du cloud** : AWS, Azure, GCP, etc.
- **Gestion d'√©tat** : Suit l'√©tat actuel de l'infrastructure
- **Planification** : Pr√©visualiser les modifications avant de les appliquer
- **Gestion des d√©pendances** : R√©solution automatique

üí° _Gestion d'√©tat, planification et d√©pendances seront vus en d√©tail durant les exercices_

---

# 3. Approches traditionnelles vs Terraform

---

## Approche 1 : Configuration manuelle

**Cr√©er une instance EC2 manuellement :**
1. Se connecter √† la console AWS
2. Naviguer vers EC2
3. Cliquer sur "Launch Instance"
4. Configurer AMI, type, stockage, tags
5. Lancer et sauvegarder la cl√© TODO v√©rifier ce que c'est

---

## Probl√®mes de l'approche manuelle

- ‚ùå Fastidieux (lourdeur des portails des cloud providers)
- ‚ùå Risque d'oubli d'un param√®tre
- ‚ùå Difficile √† reproduire
- ‚ùå Chronophage pour plusieurs ressources
- ‚ùå Pas de contr√¥le de version
- ‚ùå Connaissances dans la t√™te des gens
- ‚ùå Pas de piste d'audit

---

## Solution Terraform

```hcl
resource "aws_instance" "web" {
  ami           = "ami-0c55b159cbfafe1f0"
  instance_type = "t2.micro"

  tags = {
    Name = "WebServer"
  }
}
```

---

## Avantages Terraform

- ‚úÖ Versionn√© dans Git
- ‚úÖ Une commande : `terraform apply`
- ‚úÖ Document√© dans le code
- ‚úÖ Scalable (1 ou 100 instances)

---

## Approche 2 : Scripts shell

```bash
#!/bin/bash
# Cr√©er VPC
VPC_ID=$(aws ec2 create-vpc --cidr-block 10.0.0.0/16 \
  --query 'Vpc.VpcId' --output text)

# Cr√©er Subnet
SUBNET_ID=$(aws ec2 create-subnet --vpc-id $VPC_ID \
  --cidr-block 10.0.1.0/24 --output text)

# Cr√©er instance
aws ec2 run-instances --image-id ami-xxx \
  --instance-type t2.micro --subnet-id $SUBNET_ID
```

---

## Probl√®mes des scripts shell

- ‚ùå Mod√®le **Imp√©ratif** : sp√©cifier chaque √©tape
- ‚ùå Pas de gestion des d√©pendances : **dans le bon ordre**
- ‚ùå Pas de gestion d'√©tat : Une r√©-ex√©cution cr√©e des doublons
- ‚ùå Gestion d'erreurs complexe : mon script a fait une erreur √† la ligne 700 üò±
- ‚ùå Pas de dry-run

---

## Solution Terraform (d√©clarative)

```hcl
resource "aws_vpc" "main" {
  cidr_block = "10.0.0.0/16"
}

resource "aws_subnet" "public" {
  vpc_id     = aws_vpc.main.id
  cidr_block = "10.0.1.0/24"
}

resource "aws_instance" "web" {
  ami           = "ami-0c55b159cbfafe1f0"
  instance_type = "t2.micro"
  subnet_id     = aws_subnet.public.id
}
```

---

## Avantages de Terraform

- ‚úÖ Mod√®le **D√©claratif** : d√©crire l'√©tat souhait√©
- ‚úÖ R√©solution automatique des d√©pendances : l'ordre n'importe pas
- ‚úÖ Gestion d'√©tat : il sait ce qui existe
- ‚úÖ Idempotent : on peut l'ex√©cuter plusieurs fois sans probl√®me
- ‚úÖ Mises √† jour et suppressions faciles

---

## Approche 3 : Outils cloud-sp√©cifiques

**CloudFormation (AWS), ARM Templates (Azure)**

**Probl√®mes :**
- ‚ùå Verrouillage fournisseur
- ‚ùå Limit√© √† un seul cloud
- ‚ùå Syntaxe JSON/YAML complexe

---

## Workflow Terraform

```
Code Terraform (.tf)
       ‚Üì
terraform init
       ‚Üì
terraform plan
       ‚Üì
terraform apply
       ‚Üì
Ressources r√©elles
```

---

# 4. Terraform vs Ansible

---

## Diff√©rences cl√©s

|   | Ansible | Terraform |
|--------|---------|-----------|
| **Objectif** | Configuration de serveurs| Provisionnement de ressources|
| **Langage** | YAML | HCL (Hashicorp Configuration Language) |
| **√âtat** | Sans √©tat | Avec √©tat |
| **Approche** | Push (SSH) | API-based |

‚ö†Ô∏è Il y a des actions r√©alisables avec les deux outils

---

## Exemple : Ansible

```yaml
- name: Provision EC2 instance
  hosts: localhost
  tasks:
    - name: Create EC2 instance
      ec2:
        key_name: mykey
        instance_type: t2.micro
        image: ami-0c55b159cbfafe1f0
        region: us-east-1
```

---

## Exemple : Terraform

```hcl
resource "aws_instance" "web" {
  ami           = "ami-0c55b159cbfafe1f0"
  instance_type = "t2.micro"
  key_name      = "mykey"

  tags = {
    Name = "WebServer"
  }
}

output "instance_ip" {
  value = aws_instance.web.public_ip
}
```

---

## Quand utiliser Ansible ?

- Configuration de logiciels sur serveurs existants
- D√©ploiement d'applications
- Commandes ad-hoc
- Gestion de fichiers de configuration
- Orchestration multi-√©tapes

‚û°Ô∏è "Comment configurer ces serveurs ?"

---

## Quand utiliser Terraform ?

- Cr√©ation d'infrastructure cloud
- Gestion du cycle de vie (cr√©er, modifier, d√©truire) de ressources cloud
- Modules d'infrastructure r√©utilisables

‚û°Ô∏è "De quelle infrastructure ai-je besoin ?"

---

## Utilisez les deux ensemble !

```
Terraform ‚Üí Cr√©er l'infrastructure
  ‚îú‚îÄ Instances EC2
  ‚îú‚îÄ RDS
  ‚îî‚îÄ Load balancer
     ‚Üì
Ansible ‚Üí Configurer l'infrastructure
  ‚îú‚îÄ Installer logiciels
  ‚îú‚îÄ Configurer applications
  ‚îî‚îÄ D√©ployer le code
```

---

## Workflow combin√©

```bash
# 1. Cr√©er l'infrastructure
terraform apply

# 2. Obtenir les IPs
terraform output -json > inventory.json

# 3. Configurer les serveurs
ansible-playbook -i inventory.json configure.yml
```

- ‚ö†Ô∏è les outputs doivent √™tre adapt√©s ‚ö†Ô∏è
- l'utilisation de l'inventaire automatique est quand m√™me pr√©f√©rable

---

# 5. Concepts fondamentaux

---

## Providers (Fournisseurs)

Les providers sont des plugins permettant √† Terraform d'interagir avec les APIs.

```hcl
provider "aws" {
  region = "us-east-1"
}

provider "google" {
  project = "my-gcp-project"
  region  = "us-central1"
}
```

---

## Providers populaires

- **Cloud** : AWS, Azure, Google Cloud
- **Containers** : Kubernetes, Docker
- **DevOps** : GitHub, GitLab
- **Monitoring** : Datadog, PagerDuty
- **Et plus de 2000 autres !**

---

## Resources (Ressources)

Les ressources sont l'√©l√©ment central de Terraform.
Elles sont fournies par les providers.
1 ressource $\approx$ 1 √©l√©ment d'infrastructure
**Syntaxe :**
```hcl
resource "TYPE_RESSOURCE" "NOM" {
  argument1 = valeur1
  argument2 = valeur2
}
```

---

## Exemple de ressource

```hcl
resource "aws_instance" "web" {
  ami           = "ami-0c55b159cbfafe1f0"
  instance_type = "t2.micro"

  tags = {
    Name = "MyWebServer"
  }
}

# R√©f√©rencer une autre ressource
resource "aws_eip" "web_ip" {
  instance = aws_instance.web.id
}
```

---

## Data Sources (Sources de donn√©es)

R√©cup√©rer des informations sur des ressources existantes.

```hcl
data "aws_ami" "amazon_linux" {
  most_recent = true
  owners      = ["amazon"]

  filter {
    name   = "name"
    values = ["amzn2-ami-hvm-*"]
  }
}
```

---

## Utiliser une Data Source

```hcl
resource "aws_instance" "web" {
  ami = data.aws_ami.amazon_linux.id
  instance_type = "t2.micro"
}
```

---

## Variables

Rendre les configurations r√©utilisables.

```hcl
variable "instance_type" {
  description = "Type d'instance EC2"
  type        = string
  default     = "t2.micro"
}

variable "environment" {
  description = "Nom de l'environnement"
  type        = string
}
```

---

## Utilisation des variables

```hcl
resource "aws_instance" "web" {
  ami           = "ami-0c55b159cbfafe1f0"
  instance_type = var.instance_type

  tags = {
    Name        = "web-${var.environment}"
    Environment = var.environment
  }
}
```

---

## Passer des variables

**Ligne de commande :**
```bash
terraform apply \
  -var="instance_type=t2.small" \
  -var="environment=prod"
```

**Fichier terraform.tfvars :**
```hcl
instance_type = "t2.small"
environment   = "prod"
```

---

## Outputs (Sorties)

Afficher des informations apr√®s l'ex√©cution.

```hcl
output "instance_ip" {
  description = "IP publique"
  value       = aws_instance.web.public_ip
}

output "instance_id" {
  value = aws_instance.web.id
}
```

---

## Utilisation des outputs

```bash
$ terraform output
instance_ip = "54.123.45.67"
instance_id = "i-0abcd1234efgh5678"
```

---

## State (√âtat)

Le fichier `terraform.tfstate` est la base de donn√©es de Terraform :
- IDs des ressources
- Configuration actuelle
- M√©tadonn√©es et d√©pendances

Terraform :
- Le tient √† jour
- Sait exactement ce qui existe
- Compare facilement le code et le _state_ : planification rapide

‚õî Ne pas modifier l'infrastructure par un autre moyen

‚õî Ne pas modifier le _state_ soi-m√™me

---

## Emplacements du State

- **Local** : Sur votre machine (d√©faut)
- **Distant** : S3, Terraform Cloud (recommand√©)

```hcl
terraform {
  backend "s3" {
    bucket = "my-terraform-state"
    key    = "prod/terraform.tfstate"
    region = "us-east-1"
  }
}
```

---

## S√©curit√© du State

‚ö†Ô∏è **Consid√©rations importantes :**
- Contient des donn√©es sensibles - s√©curisez-le !
- Ne jamais l'√©diter manuellement
- Utiliser l'√©tat distant pour la collaboration
- Activer le verrouillage d'√©tat

---

## Idempotence

Ex√©cuter plusieurs fois `terraform apply` ‚Üí m√™me r√©sultat final

```bash
$ terraform apply  # Cr√©e 1 instance
$ terraform apply  # Aucun changement
$ terraform apply  # Aucun changement
```

**Comment :**
1. Lire l'√©tat souhait√© (`.tf`)
2. Lire l'√©tat actuel (`.tfstate`)
3. Appliquer uniquement les diff√©rences

---

## Modules

Conteneurs pour plusieurs ressources utilis√©es ensemble.

**Structure :**
```
modules/
  ‚îî‚îÄ‚îÄ vpc/
      ‚îú‚îÄ‚îÄ main.tf
      ‚îú‚îÄ‚îÄ variables.tf
      ‚îî‚îÄ‚îÄ outputs.tf
```

---

## D√©finition de module

```hcl
resource "aws_vpc" "main" {
  cidr_block = var.vpc_cidr

  tags = {
    Name = var.vpc_name
  }
}

resource "aws_subnet" "public" {
  vpc_id     = aws_vpc.main.id
  cidr_block = var.public_subnet_cidr
}
```

---

## Utilisation du module

```hcl
module "vpc" {
  source = "./modules/vpc"

  vpc_name           = "production-vpc"
  vpc_cidr           = "10.0.0.0/16"
  public_subnet_cidr = "10.0.1.0/24"
}

resource "aws_instance" "web" {
  subnet_id = module.vpc.public_subnet_id
}
```

---

## Avantages des modules

- ‚úÖ R√©utilisabilit√© du code
- ‚úÖ Organisation
- ‚úÖ Encapsulation
- ‚úÖ Contr√¥le de version des composants

---

## Un point sur l'organisation des fichiers

- Seule l'extension est vraiment importante (`.tf`)
- Il n'y a pas d'ordre √† respecter (puisque c'est **d√©claratif**)
- Terraform lit tous les fichiers du r√©pertoire courant, retrouve les providers d√©clar√©s, les d√©finitions de variables, les `locals`, les ressources, les outputs, et construit un arbre de d√©pendances pour savoir dans quel ordre il faut proc√©der
- **Conclusion:** on peut tout √©crire dans 1 seul fichier `.tf`, **mais** on pr√©f√©rera r√©partir les √©l√©ments dans des fichiers avec des noms qui ont du sens

---

## Commandes de base

```bash
terraform init      # Initialiser
terraform fmt       # Formater
terraform validate  # Valider
terraform plan      # Voir changements
terraform apply     # Appliquer
terraform output    # Voir outputs
terraform destroy   # D√©truire
```

---

# 6. Flux de travail Terraform

---

## Le flux principal

```
√âcrire ‚Üí Init ‚Üí Plan ‚Üí Apply ‚Üí Destroy
```

---

## terraform init

Initialise un r√©pertoire de travail, installe les providers et modules.

```bash
terraform init
```

**Quand l'ex√©cuter :**
- Premi√®re fois dans un projet
- Apr√®s ajout de providers/modules

---

## terraform plan

Cr√©e un plan d'ex√©cution.

```bash
terraform plan
```

**Symboles :**
- `+` : Ressource cr√©√©e
- `-` : Ressource d√©truite
- `~` : Ressource modifi√©e
- `-/+` : Ressource remplac√©e

---

## Exemple de sortie plan

```
Terraform will perform the following actions:

  # aws_instance.web will be created
  + resource "aws_instance" "web" {
      + ami           = "ami-0c55b159cbfafe1f0"
      + instance_type = "t2.micro"
      + id            = (known after apply)
    }

Plan: 1 to add, 0 to change, 0 to destroy.
```

---

## terraform apply

Applique les changements.

```bash
terraform apply

# Auto-approuver
terraform apply -auto-approve

# Avec variables
terraform apply -var="instance_type=t2.small"
```

---

## terraform destroy

D√©truit toutes les ressources g√©r√©es.

```bash
terraform destroy

# D√©truire une ressource sp√©cifique
terraform destroy -target=aws_instance.web
```

---

## terraform fmt

Formater le code.

```bash
terraform fmt              # Formater
terraform fmt -check       # V√©rifier
terraform fmt -recursive   # R√©cursif
```

---

## terraform validate

Valider la syntaxe.

```bash
terraform validate
```

---

## Commandes d'√©tat

```bash
# Lister les ressources
terraform state list

# Afficher une ressource
terraform state show aws_instance.web

# Retirer de l'√©tat
terraform state rm aws_instance.web

# Renommer
terraform state mv aws_instance.old aws_instance.new
```

---

## Autres commandes utiles

```bash
# Afficher l'√©tat actuel
terraform show

# Sync avec l'infra r√©elle
terraform refresh

# Cr√©er un graphe
terraform graph | dot -Tpng > graph.png
```

---

# 7. Concepts avanc√©s

---

## Locals

Valeurs locales pour la r√©utilisation.

```hcl
locals {
  common_tags = {
    Environment = "Production"
    ManagedBy   = "Terraform"
  }
  instance_name = "${var.project}-${var.env}-web"
}

resource "aws_instance" "web" {
  tags = merge(local.common_tags, {
    Name = local.instance_name
  })
}
```

---

## Count

```hcl
resource "aws_instance" "server" {
  count         = 3
  ami           = var.ami_id
  instance_type = "t2.micro"

  tags = {
    Name = "server-${count.index}"
  }
}
```

---

## for_each

```hcl
variable "instances" {
  default = {
    web = { instance_type = "t2.micro" }
    api = { instance_type = "t2.small" }
  }
}

resource "aws_instance" "server" {
  for_each      = var.instances
  ami           = var.ami_id
  instance_type = each.value.instance_type

  tags = { Name = each.key }
}
```

---

## Expressions conditionnelles

```hcl
resource "aws_instance" "web" {
  ami = var.ami_id
  instance_type = var.environment == "production" ? \
                  "t2.large" : "t2.micro"

  tags = {
    Name = var.environment == "production" ? \
           "prod-web" : "dev-web"
  }
}
```

---

## Blocs dynamiques : Variable

```hcl
variable "ingress_rules" {
  type = list(object({
    port        = number
    cidr_blocks = list(string)
  }))
  default = [
    { port = 80,  cidr_blocks = ["0.0.0.0/0"] },
    { port = 443, cidr_blocks = ["0.0.0.0/0"] }
  ]
}
```

---

## Blocs dynamiques : Utilisation

```hcl
resource "aws_security_group" "web" {
  name = "web-sg"

  dynamic "ingress" {
    for_each = var.ingress_rules
    content {
      from_port   = ingress.value.port
      to_port     = ingress.value.port
      protocol    = "tcp"
      cidr_blocks = ingress.value.cidr_blocks
    }
  }
}
```

---

## Workspaces : Commandes

G√©rer plusieurs environnements.

```bash
# Lister
terraform workspace list

# Cr√©er et basculer
terraform workspace new dev
terraform workspace new prod

# Basculer
terraform workspace select dev
```

---

## Workspaces : Utilisation

```hcl
resource "aws_instance" "web" {
  ami = var.ami_id
  instance_type = terraform.workspace == "prod" ? \
                  "t2.large" : "t2.micro"

  tags = {
    Name        = "web-${terraform.workspace}"
    Environment = terraform.workspace
  }
}
```

---

## Remote State Data Source

Partager outputs entre configurations.

**Projet A :**
```hcl
output "vpc_id" {
  value = aws_vpc.main.id
}
```

---

## Remote State : Consommation

**Projet B :**
```hcl
data "terraform_remote_state" "vpc" {
  backend = "s3"
  config = {
    bucket = "my-terraform-state"
    key    = "vpc/terraform.tfstate"
    region = "us-east-1"
  }
}

# Utiliser
resource "aws_instance" "web" {
  subnet_id = data.terraform_remote_state.vpc.outputs.subnet_id
}
```

---

# 8. Outils alternatifs

---

## OpenTofu

Fork open-source de Terraform cr√©√© suite au changement de licence de Terraform.

**Points cl√©s :**
- 100% compatible avec Terraform
- M√™me syntaxe HCL
- G√©r√© par la communaut√©
- Vraiment open source

üîç En fait le changement de licence impacte peu de monde et ne concerne que les entreprises qui vendent une solution d'infrastructure ou de gestion de cloud int√©grant Terraform. Quelques soci√©t√©s concern√©es : Pulumi, Spacelift, Scalr, Aiven

---

## Ressources

- **Documentation** : terraform.io/docs
- **Terraform Registry** : registry.terraform.io
- **Provider AWS** : registry.terraform.io/providers/hashicorp/aws
- **HashiCorp Learn** : learn.hashicorp.com
- **Communaut√©** : discuss.hashicorp.com

